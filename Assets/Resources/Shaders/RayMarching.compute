// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> Source;
RWTexture2D<float4> Result;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;

static const float maxDst = 80;
static const float epsilon = 0.001f;

struct Shape {
    
    float3 position;
    float3 size;
    float3 color;
    float3 colliderMin;
    float3 colliderMax;
    int shapeType;
    float sigmaA;
};

struct ShapeInfo {
    Shape shape;
    float distToShape;
};

StructuredBuffer<Shape> shapes;
int numShapes;

struct Ray {
    float3 origin;
    float3 direction;
};

Ray CreateRay(float3 origin, float3 direction) {
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}


Ray CreateCameraRay(float2 uv) {
    float3 origin = mul(_CameraToWorld, float4(0,0,0,1)).xyz;
    float3 direction = mul(_CameraInverseProjection, float4(uv,0,1)).xyz;
    direction = mul(_CameraToWorld, float4(direction,0)).xyz;
    direction = normalize(direction);
    return CreateRay(origin,direction);
}

bool RaySphereIntersection(float3 rayOrigin, float3 rayDir, float3 sphereCenter, float sphereRadius, out float tEnter, out float tExit)
{
    float3 oc = rayOrigin - sphereCenter;

    float a = dot(rayDir, rayDir); // usually 1 if rayDir is normalized
    float b = 2.0 * dot(oc, rayDir);
    float c = dot(oc, oc) - sphereRadius * sphereRadius;

    float discriminant = b * b - 4.0 * a * c;

    if (discriminant < 0.0)
    {
        tEnter = 0.0;
        tExit = 0.0;
        return false; // no intersection
    }

    float sqrtDisc = sqrt(discriminant);
    float invDenom = 0.5 / a;

    float t0 = (-b - sqrtDisc) * invDenom;
    float t1 = (-b + sqrtDisc) * invDenom;

    tEnter = min(t0, t1);
    tExit = max(t0, t1);

    return tExit >= max(tEnter, 0.0);
}


bool RayBoxIntersection(Shape shape, float3 rayOrigin, float3 rayDir, out float tEnter, out float tExit)
{
    float3 invDir = 1.0 / rayDir;

    float3 t0s = (shape.colliderMin - rayOrigin) * invDir;
    float3 t1s = (shape.colliderMax - rayOrigin) * invDir;

    float3 tSmalls = min(t0s, t1s);
    float3 tBigs = max(t0s, t1s);

    tEnter = max(max(tSmalls.x, tSmalls.y), tSmalls.z);
    tExit = min(min(tBigs.x, tBigs.y), tBigs.z);

    return tExit >= max(tEnter, 0.0);
}

bool RayShapeIntersection(Shape shape, float3 rayOrigin, float3 rayDir, out float tEnter, out float tExit) 
{
    if(shape.shapeType == 0) 
    {
        return RaySphereIntersection(rayOrigin, rayDir, shape.position, shape.size, tEnter, tExit);
    }
    if(shape.shapeType == 1) 
    {
        return RayBoxIntersection(shape, rayOrigin, rayDir, tEnter, tExit);    
    }
    return false;
}

float sdBox(float3 p, float3 b)
{
    float3 q = abs(p) - b;
    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

float sdSphere(float3 rayPos, float s )
{
    return length(rayPos) - s;
}

float getShapeDistance(float3 eye, Shape shape) 
{
    if(shape.shapeType == 0) 
    {
        return sdSphere(eye - shape.position, shape.size);    
    }
    if(shape.shapeType == 1) 
    {
        return sdBox(eye - shape.position ,shape.size);    
    }
    return maxDst;
}


ShapeInfo SceneInfo(float3 eye) {
    ShapeInfo info;
    float globalDst = maxDst;
    Shape shape;
    for (int i = 0; i < numShapes; i++) 
    {
        float distToShape = getShapeDistance(eye, shapes[i]);
        if(globalDst > distToShape) 
        {
            globalDst = distToShape;
            shape = shapes[i];
        }
    }
    if (globalDst > maxDst)
    {
        globalDst = maxDst;
    }
    if (globalDst < epsilon)
    {
        globalDst = epsilon;
    }
    info.shape = shape;
    info.distToShape = globalDst;
    return info;
}


[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    Result[id.xy] = Source[id.xy];
    
    uint width,height;
    Result.GetDimensions(width, height);
    float2 uv = id.xy / float2(width,height) * 2 - 1;
    float rayDst = 0;

    Ray ray = CreateCameraRay(uv);
    int marchSteps = 0;

    while (rayDst < maxDst) {
        marchSteps ++;
        ShapeInfo info = SceneInfo(ray.origin);

        if (info.distToShape <= epsilon)
        {
            float tEnter, tExit = 0;
            if (RayShapeIntersection(info.shape,  ray.origin, ray.direction, tEnter, tExit))
            {
                // Save the original ray origin
                float3 originalOrigin = ray.origin;
                
                // Move ray origin to entry point
                float3 entryPoint = originalOrigin + ray.direction * tEnter;
                
                // Sample positions along the ray inside the box
                float stepSize = (tExit - tEnter) / 100.0; // Adjust number of steps as needed
                float t = 0;
                float3 color = float3(0, 0, 0);
                float alpha = 0;
                
                // Raymarching loop inside the box
                for (int i = 0; i < 100; i++) // Adjust max iterations as needed
                {
                    t = tEnter + i * stepSize;
                    
                    if (t > tExit) break;
                    
                    // Current position along the ray
                    float3 pos = originalOrigin + ray.direction * t;
                    
                    // Sample your volume data at this position
                    // This is where you'll evaluate your density function, color transfer, etc.
                    float density = info.shape.sigmaA; // You'll need to implement this function
                    
                    if (density > 0.01) // Adjust threshold as needed
                    {
                        // Simple color mapping based on position

                        float3 sampleColor = info.shape.color;

                        /*float3 sampleColor = float3(
                            (pos.x - _boxMin.x) / (_boxMax.x - _boxMin.x),
                            (pos.y - _boxMin.y) / (_boxMax.y - _boxMin.y),
                            (pos.z - _boxMin.z) / (_boxMax.z - _boxMin.z)
                        );
                        */
                        // Accumulate color (basic front-to-back compositing)
                        float a = density * stepSize * 1.0; // Adjust density scale as needed
                        color = color + (1.0 - alpha) * a * sampleColor;
                        alpha = alpha + (1.0 - alpha) * a;
                        
                        // Early ray termination
                        if (alpha >= 0.95) break;
                    }
                }
                
                // Output the final color with alpha composited over the background
                float3 backgroundColor = Source[id.xy].rgb;
                color = color + (1.0 - alpha) * backgroundColor;
                Result[id.xy] = float4(color, 1.0);
                return;
            }
        }
        ray.origin += ray.direction * info.distToShape;
        rayDst += info.distToShape;
    }
}
